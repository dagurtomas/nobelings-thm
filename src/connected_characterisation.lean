import topology.connected
import tactic.fin_cases

universe u

instance disc_top_Prop : topological_space Prop := ⟨λ x, true, by triv, by tauto, by tauto⟩

instance disc_Prop : discrete_topology Prop := by {fconstructor, refl}

def char_func {X : Type u} (U : set X) : X → Prop := λ x, x ∈ U

def setProp : list (set Prop) := [∅, set.univ, {true}, {false}]

lemma mem_setProp (s : set Prop) : s ∈ setProp :=
begin
  by_cases ht : true ∈ s,
    by_cases hf : false ∈ s,
    { have h : s = set.univ,
      ext, split, { tauto },
      intros hx,
      by_cases hx' : x,
      have hx'' : x = true := by tidy, rw hx'', exact ht,
      have hx'' : x = false := by tidy, rw hx'', exact hf, 
      unfold setProp, tidy, tauto, },
    { have h : s = {true},
      ext, split, 
      { intros hx,
        by_cases hx' : x,
        have hx'' : x = true := by tidy, rw hx'', tauto, 
        have hx'' : x = false := by tidy, exfalso, apply hf, rw hx'' at hx, exact hx, },
      { intros hx,
        by_cases hx' : x,
        have hx'' : x = true := by tidy, rw hx'', exact ht,
        have hx'' : x = false := by tidy, exfalso, tidy, },
      unfold setProp, tidy, tauto, },
    by_cases hf : false ∈ s,
    { have h : s = {false},
      ext, split, 
      { intros hx,
        by_cases hx' : x,
        have hx'' : x = true := by tidy, exfalso, apply ht, rw hx'' at hx, exact hx,
        have hx'' : x = false := by tidy, rw hx'', tauto, },
      { intros hx,
        by_cases hx' : x,
        have hx'' : x = true := by tidy, exfalso, tidy, 
        have hx'' : x = false := by tidy, rw hx'', exact hf, },
      unfold setProp, tidy, tauto, },
    { have h : s = ∅,
      ext, split, swap, { tauto },
      intros hx,
      exfalso,
      by_cases hx' : x, 
      have hx'' : x = true := by tidy, rw hx'' at hx, apply ht, exact hx,
      have hx'' : x = false := by tidy, rw hx'' at hx, apply hf, exact hx, 
      unfold setProp, tidy, tauto, },
end

lemma char_func_continuous {X : Type u} (U : set X) [topological_space X] : 
  continuous (char_func U) ↔ is_clopen U :=
begin
  have hUt : (char_func U) ⁻¹' {true} = U := by tidy,
  have hUf : (char_func U) ⁻¹' {false} = Uᶜ := by tidy,
  have hUX : (char_func U) ⁻¹' set.univ = set.univ := by tidy,
  have hUe : (char_func U) ⁻¹' ∅ = ∅ := by tidy,
  have h_is_clopen_true : is_clopen ({true} : set Prop) := ⟨is_open_discrete {true}, is_closed_discrete {true}⟩,
  -- let A : list (set Prop) := [∅, set.univ, {true}, {false}],
  have h_set_Prop_fin : ∀ s : set Prop, s ∈ setProp :=  λ s, mem_setProp s,
  split,
  { intros hc,
    rw ← hUt, 
    exact ⟨is_open.preimage hc h_is_clopen_true.1, is_closed.preimage hc h_is_clopen_true.2⟩, },
  { intros hU,
    refine {is_open_preimage := _},
    intros S hS,
    specialize h_set_Prop_fin S,
    fin_cases h_set_Prop_fin,
    { rw hUe, exact is_open_empty },
    { rw hUX, exact is_open_univ },
    { rw hUt, exact hU.1 },
    { rw hUf, refine is_closed.not _, exact hU.2 }, },
end

lemma connected_characterisation (X : Type u) [topological_space X] : (∀ f : X → Prop, ∀ hf : continuous f, ∀ a b : X, f a = f b) → preconnected_space X :=
begin
  intros h,
  fconstructor,
  unfold is_preconnected,
  intros U V hU hV hUnion hneU hneV,
  simp at *,
  by_contra h1,
  have heUV : U ∩ V = ∅,
  ext,
  split,
  intros hx,
  exfalso,
  apply h1,
  use x,
  exact hx,
  tauto,
  have hUnion' : U ∪ V = set.univ,
  ext,
  split,
  tauto,
  intros hx,
  apply hUnion,
  exact hx,
  have h_V_in_Uc : V ⊆ Uᶜ,
  -- ext,
  -- split,
  intros x,
  by_cases hxU : x ∈ U,
  intros hx,
  have hxe : x ∈ U ∩ V,
  split,
  exact hxU,
  exact hx,
  rw heUV at hxe,
  exfalso,
  exact hxe,
  intros hx,
  exact hxU,
  have h_Uc_in_V : Uᶜ ⊆ V,
  rw set.compl_subset_iff_union,
  exact hUnion',
  have h_V_eq_Uc : V = Uᶜ,
  ext,
  split,
  intros hx,
  apply h_V_in_Uc,
  exact hx,
  intros hx,
  apply h_Uc_in_V,
  exact hx,
  have hcU : is_clopen U,
  split,
  exact hU,
  refine {is_open_compl := _},
  rw ← h_V_eq_Uc,
  exact hV,

  rw ← char_func_continuous U at hcU,
  specialize h (char_func U),
  have habU := h hcU,
  obtain ⟨u, hu⟩ := hneU,
  obtain ⟨v, hv⟩ := hneV,
  specialize habU u v,
  have hu' : char_func U u,
  exact hu,
  rw h_V_eq_Uc at hv,
  have hv' : v ∉ U,
  exact hv,
  have hv'' : ¬(char_func U v),
  exact hv',
  apply hv'',
  exact habU.1 hu',
end

lemma connected_characterisation' {X : Type u} (α : set X) [topological_space X] :
  (∀ f : α → Prop', ∀ hf : continuous f, ∀ a b : ↥α, f a = f b) → is_preconnected α :=
begin
  -- exact connected_characterisation α 
  
  -- have hh : preconnected_space α := connected_characterisation α h,
  -- contrapose,
  -- unfold is_preconnected,
  -- simp,
  -- intros U hU V hV haUV haU haV nhaUV,
  -- use char_func (U ∩ V),
  -- split,
  -- apply (char_func_continuous _).mpr,
  -- split,
  -- exact (is_open.and hU hV),
  -- refine is_closed.inter _ _,
  -- -- cases haU,
  -- -- use haU_w,
  -- -- split,
  -- -- have hh : α ∩ U ⊆ α,
  -- -- intros a ha,
  -- -- exact ha.1,
  -- -- apply hh,
  -- -- exact haU_h,
  -- -- cases haV,
  -- -- use haV_w,
  -- -- split,
  -- -- have hh1 : α ∩ V ⊆ α,
  -- -- intros a ha,
  -- -- exact ha.1,
  -- -- apply hh1,
  -- -- exact haV_h,
  -- -- intros h,
  -- -- apply nhaUV,
  -- -- use haU_w,
  -- -- suffices hs : char_func (U ∩ V) haU_w,
  -- -- have hh2 : α ∩ (U ∩ V) ⊆ U ∩ V,
  -- -- intros a ha,
  -- -- exact ha.2,
  -- -- apply hh2,
  -- -- exact hs,
  -- -- intros h,
  -- -- unfold is_preconnected,
  -- -- intros U V,
  -- -- intros hU hV,
  -- -- intros haUV haU haV,
  -- -- let fU := char_func U,
  -- -- let fV := char_func V,
  -- -- let f := char_func (U ∩ V),
end